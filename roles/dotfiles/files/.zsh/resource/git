
# 
# GIT
#

gvmod() { _s $1; vim `git status --porcelain | sed -ne 's/^ M //p'` }
# TODO: Make so if not in git root then go to correct location

gdo() { if [ -d "$1" ] ; then _s $1 ; fi; ${EDITOR} -p `git diff --name-only | uniq`; }

gmcb() { #Git merge current branch
  current=$(git rev-parse --abbrev-ref HEAD);
  git checkout master; git pull;
  git merge $current;
}

gstatus() {
  #In Linux an M is placed before each change
  changes=$(git status -s | sed -e "s/M *//" -e "s/?? //") &&
  select=$(echo "$changes" | fzf -m)
  echo "$select"
}

g--() {
  git checkout -- $(gstatus)
}

gdiff() {
  if [ "$1" == "-h" ]; then
    diff=$(git diff HEAD --name-only)
  elif [ "$1" == "-2" ]; then
    diff=$(git diff HEAD~2 --name-only)
  elif [ "$1" == "-3" ]; then
    diff=$(git diff HEAD~3 --name-only)
  elif [ "$1" == "-4" ]; then
    diff=$(git diff HEAD~4 --name-only)
  elif [ "$1" == "-m" ]; then
    diff=$(git diff master...HEAD --name-only)
  else
    diff=$(git diff @{u}...HEAD --name-only)
    # equal
    # @{u}...HEAD
    # git rev-parse --abbrev-ref --symbolic-full-name @{u}
  fi
  echo $diff
}

vdiff() {
  flag=$1
  diff=$(gdiff $flag)
  GROOT="$(git rev-parse --show-toplevel 2> /dev/null || echo -n '.')";
  CURRENT=$(pwd)

  # params contains more than spaces
  if [[ $diff = *[!\ ]* ]]; then
    cd "$GROOT"
    ${EDITOR} $(echo $diff | tr '\r\n' ' ')
    cd "$CURRENT"
  else
    echo 'Ay. Nothing to see here!'
  fi
}

gac() {
  diff=$(git ls-files -m | fzf --multi --preview "head -$LINES {}" )
  git add $(echo $diff | tr '\r\n' ' ');
  if [[ -z "$1" ]] ; then
    git commit
  else
    git commit -m "$1"
  fi
}

merge_conflicts() {
  top=$(git rev-parse --show-toplevel 2> /dev/null || echo -n ".");
  docs=$(ag -l '<<<<<<<' $top);
  echo "$docs";
}

fmi() {
  doc=$(merge_conflicts | fzf --multi --preview "head -$LINES {}" ) &&
  ${EDITOR} -p $( echo "$doc" | tr '\r\n' ' ');
  # git mergetool $( echo "$doc" | tr '\r\n' ' ');
}

branch() {
  branches=$(git branch -vv) &&
  branch=$(echo "$branches" | fzf +m) &&
  b=$(echo "$branch" | sed "s/\* //" | awk '{print $1}' | sed "s/.* //")
  echo $b;
}

gall() {
  if [[ -z "$1" ]] ; then
    git add --all && git commit && git push;
  elif [[ -z "$2" ]] ; then
    git add --all && git commit -m $1 && git push ;
  else
    git add --all && git commit -m $1 -m $2 && git push ;
  fi;
}

gallup() {
  if [[ -z "$2" ]] ; then
    git add --all && git commit -m $1 && git push -u origin $(git branch | grep \* | cut -d ' ' -f2);
  else
    git add --all && git commit -m $1 -m $2 && git push -u origin $(git branch | grep \* | cut -d ' ' -f2);
  fi;
}

gup() {
  if [[ -z "$2" ]] ; then
    git commit -m $1 && git push -u origin $(git branch | grep \* | cut -d ' ' -f2);
  else
    git commit -m $1 -m $2 && git push -u origin $(git branch | grep \* | cut -d ' ' -f2);
  fi;
}

ghistory() { git rev-list --all | xargs git grep "$1" }

select_branch() {
  branches=$(git branch -vv) &&
  branch=$(echo "$branches" | fzf +m) &&
  select=$(echo "$branch" | awk '{print $1}' | sed "s/.* //");
  echo $select;
}

clean_branches() {
# Todo - make it so you can select more than one
  select=$(select_branch) &&
  git branch -D "$select" &&
  git branch -D -r "origin/$select" &&
  git push origin --delete "$select"
}

fshow() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --header "Press CTRL-S to toggle sort" \
      --preview "echo {} | grep -o '[a-f0-9]\{7\}' | head -1 |
                 xargs -I % sh -c 'git show --color=always % | head -$LINES'" \
      --bind "enter:execute:echo {} | grep -o '[a-f0-9]\{7\}' | head -1 |
              xargs -I % sh -c 'vim fugitive://\$(git rev-parse --show-toplevel)/.git//% < /dev/tty'"
}

# git_next() { gall "merge"; g skip; fmi; }

fbr() {
  local branches branch
  branches=$(git branch -vv) &&
  branch=$(echo "$branches" | fzf +m) &&
  git checkout $(echo "$branch" | awk '{print $1}' | sed "s/.* //")
}


# fstash - easier way to deal with stashes
# type fstash to get a list of your stashes
# enter shows you the contents of the stash
# ctrl-d shows a diff of the stash against your current HEAD
# ctrl-b checks the stash out as a branch, for easier merging
fstash() {
  local out q k sha
  while out=$(
    git stash list --pretty="%C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b);
  do
    mapfile -t out <<< "$out"
    q="${out[0]}"
    k="${out[1]}"
    sha="${out[-1]}"
    sha="${sha%% *}"
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff $sha
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break;
    else
      git stash show -p $sha
    fi
  done
}

stashcheck() {
  git stash && git checkout $1 && git stash pop;
}

stashft() {
  git stash && git checkout -b feature/$1 && git pull origin master && git stash pop
}

stashhf() {
  git stash && git checkout -b hotfix/$1 && git pull origin master && git stash pop
}

gscs() {
  local branches branch
  branches=$(git branch -vv) &&
  branch=$(echo "$branches" | fzf +m) &&
  git stash && git checkout $(echo "$branch" | awk '{print $1}' | sed "s/.* //") && git stash pop
}

grc() {
  if [ -n "$2" ] ; then
    git reset HEAD $1 && git checkout $2 $1
  else
    git reset HEAD $1 && git checkout --ours $1
  fi
}

graw() {
  GPATH=${1/github.com/raw.githubusercontent.com}
  GPATH=${GPATH/blob\//}
  wget -nd $GPATH
}

# Sync current git commit with master
gsync() {
# Todo would like to make remote optional
 COMMITID=$(git log --format="%H" -n 1);
 git checkout $COMMITID;
 git merge remotes/origin/master;
}

# if gsync goes well - run to merge into branch of choice
gtempmerge() {
  select=$(select_branch);
  git branch temp;
  git checkout $select;
  git merge temp;
  git branch -D temp;
}

findtodos() {
  GROOT="$(git rev-parse --show-toplevel 2> /dev/null || echo -n '.')";
  ag -R 'TODO|FIXME' --ignore-dir={vendor,node_modules,dist} $GROOT;
}

gpush() {
# with ci
if todos 2>&1 > /dev/null; then
  echo 'TODOS EXIST'; 
fi
}

gitco() {
  git checkout $(git branch | fzf);
}

# GIT heart FZF
# -------------

is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fzf-down() {
  fzf --height 50% "$@" --border
}

gf() {
  is_in_git_repo || return
  git -c color.status=always status --short |
  fzf-down -m --ansi --nth 2..,.. \
    --preview '(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500' |
  cut -c4- | sed 's/.* -> //'
}

gb() {
  is_in_git_repo || return
  git branch -a --color=always | grep -v '/HEAD\s' | sort |
  fzf-down --ansi --multi --tac --preview-window right:70% \
    --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
  sed 's/^..//' | cut -d' ' -f1 |
  sed 's#^remotes/##'
}

gt() {
  is_in_git_repo || return
  git tag --sort -version:refname |
  fzf-down --multi --preview-window right:70% \
    --preview 'git show --color=always {} | head -'$LINES
}

gh() {
  is_in_git_repo || return
  git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph --color=always |
  fzf-down --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
    --header 'Press CTRL-S to toggle sort' \
    --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show --color=always | head -'$LINES |
  grep -o "[a-f0-9]\{7,\}"
}

gr() {
  is_in_git_repo || return
  git remote -v | awk '{print $1 "\t" $2}' | uniq |
  fzf-down --tac \
    --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" {1} | head -200' |
  cut -d$'\t' -f1
}

join-lines() {
  local item
  while read item; do
    echo -n "${(q)item} "
  done
}

bind-git-helper() {
  local c
  for c in $@; do
    eval "fzf-g$c-widget() { local result=\$(g$c | join-lines); zle reset-prompt; LBUFFER+=\$result }"
    eval "zle -N fzf-g$c-widget"
    eval "bindkey '^g^$c' fzf-g$c-widget"
  done
}
bind-git-helper f b t r h
unset -f bind-git-helper


# Make key bindings
bash $HOME/.zsh/bindkey


